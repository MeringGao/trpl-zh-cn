#+title:  Rust 程序设计语言

* [[file:title-page.md][Rust 程序设计语言]]
* [[file:foreword.md][前言]]
* [[file:ch00-00-introduction.md][简介]]

* DONE [[file:ch01-00-getting-started.md][入门指南]] [3/3]
CLOSED: [2024-12-26 Thu 12:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 12:46]
:END:

** DONE [[file:ch01-01-installation.md][安装]]
CLOSED: [2024-12-26 Thu 12:44]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 12:44]
:END:

** DONE [[file:ch01-02-hello-world.md][Hello, World!]]
CLOSED: [2024-12-26 Thu 12:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 12:45]
:END:

** DONE [[file:ch01-03-hello-cargo.md][Hello, Cargo!]]
CLOSED: [2024-12-26 Thu 12:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 12:45]
:END:

* DONE [[file:ch02-00-guessing-game-tutorial.md][写个猜数字游戏]]
CLOSED: [2024-12-26 Thu 12:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 12:46]
:END:

* DONE [[file:ch03-00-common-programming-concepts.md][常见编程概念]] [5/5]
CLOSED: [2024-12-26 Thu 13:08]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 13:08]
:END:

** DONE [[file:ch03-01-variables-and-mutability.md][变量与可变性]]
CLOSED: [2024-12-26 Thu 12:53]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 12:53]
:END:

常量的命名习惯, 大写加下划线

let 同名的变量名会遮蔽前面的变量名

** DONE [[file:ch03-02-data-types.md][数据类型]]
CLOSED: [2024-12-26 Thu 13:02]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 13:02]
:END:

数值类型, 数子内部可以方便使用"_" 分割, 例如 ~1000_000~

0xff 16 进制, 0o77 8 进制, 0b1111_0000 二进制, b'A' 单字节字符, 仅限于 u8, 注意
和 单字符 char 不同, char 是 4 字节的,代表 Unicode 标量值,例如: 'A', 双引号就是表示字符串, 例如: "A"
占用 1 字节,字符串长度取决于字符串的内容

i{8,16,32,64,128} u{8,16,32,64,128} isize 和 usize 是平台相关的

整型溢出, 在 debug 模式下会 panic ,但是在 release 模式下会回绕.

** DONE [[file:ch03-03-how-functions-work.md][函数]]
CLOSED: [2024-12-26 Thu 13:06]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 13:06]
:END:

rust 函数用下划线链接单词作为函数名的惯例

** DONE [[file:ch03-04-comments.md][注释]]
CLOSED: [2024-12-26 Thu 13:06]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 13:06]
:END:

** DONE [[file:ch03-05-control-flow.md][控制流]]
CLOSED: [2024-12-26 Thu 13:08]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 13:08]
:END:

loop 循环支持 label 标签, break, continue 可以跟随标签

if else loop while match

* DONE [[file:ch04-00-understanding-ownership.md][认识所有权]] [3/3]
CLOSED: [2024-12-26 Thu 20:21]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:21]
:END:

** DONE [[file:ch04-01-what-is-ownership.md][什么是所有权？]]
CLOSED: [2024-12-26 Thu 20:16]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:16]
:END:

栈和堆上的值都属于某个所有者, 栈上的数据会随着函数退出栈被清空而被清理掉, 堆上的
数据就不是这么简单了

栈上的数据都是已知大小的类型, 堆上可以存储未知大小的类型, 默认情况下已经大小的类
型赋值时是直接复制一份到栈中, 在栈上是极快的分配的

rust 内存在拥有它的变量离开作用时被自动释放

let s1 = String::from("hello");
let s2 = s1;

这里栈上会存在两个值, 一个值 s1,一个是 s2, 他们占用栈上的空间是一样的, 他们都有
一个指针, 指向堆上的一块内存, 栈上是 指针,长度,和容量三个值. s2 拥有堆上数据的所
有权, s1 和 s2 会在函数退出后, 清空栈时被清空, 同时 s2 指向的堆上数据,在 s2 离开
作用域时被释放

字符串从 s1 转移给 s2 所有权, 叫做所有权转移 (move)

像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的

如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。

** DONE [[file:ch04-02-references-and-borrowing.md][引用与借用]]
CLOSED: [2024-12-26 Thu 20:16]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:16]
:END:

引用像是一个指针, 在栈上创建了一个指针值, 这个值指向栈上的另一个值(所有权)

例如: let s=String::from("hhh") let s1=&s; 这里 s1 就是一个指针(usize 类型), s 是栈上的一个
值包含了 指针,长度,容量, 它的指针指向堆上的字符串

"&" 就是引用的, 它不会获得所有权, s1 借用了 s 的值, 创建引用的行为被称为借用

"*" 是解引用

统一时刻只能存在一个可变引用,来防止竞争修改数据,导致数据错误, 不可变引用和可变引
用不能同时存在

** DONE [[file:ch04-03-slices.md][Slice 类型]]
CLOSED: [2024-12-26 Thu 20:21]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:21]
:END:

let s = String::from("hello");
let slice = &s[0..2];
let slice = &s[..2];

slice 也是引用, 引用了原始数据的部分内容, 没有所有权

* DONE [[file:ch05-00-structs.md][使用结构体组织相关联的数据]] [3/3]
CLOSED: [2024-12-26 Thu 20:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:42]
:END:

** DONE [[file:ch05-01-defining-structs.md][结构体的定义和实例化]]
CLOSED: [2024-12-26 Thu 20:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:42]
:END:

元祖结构体, 单元结构体

读取结构体成员时, 注意结构体成员的所有权转移问题

当结构体成员是引用类型时,注意生命周期标识

** DONE [[file:ch05-02-example-structs.md][结构体示例程序]]
CLOSED: [2024-12-26 Thu 20:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:42]
:END:

dbg!(T:Debug)

** DONE [[file:ch05-03-method-syntax.md][方法语法]]
CLOSED: [2024-12-26 Thu 20:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:42]
:END:

impl T {
  fn func(&self) -> (self &T)  t.func  Rust 自动引用和解引用
  fn funcx(self) -> (self T)   t.func
}

关联函数, 就是第一个参数不是self, 这个函数是和这个结构体关联的, 用 "结构体的名
称::函数名" 进行调用

* DONE [[file:ch06-00-enums.md][枚举和模式匹配]] [3/3]
CLOSED: [2024-12-26 Thu 20:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:45]
:END:

** DONE [[file:ch06-01-defining-an-enum.md][枚举的定义]]
CLOSED: [2024-12-26 Thu 20:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:45]
:END:

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}


** DONE [[file:ch06-02-match.md][`match` 控制流结构]]
CLOSED: [2024-12-26 Thu 20:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:45]
:END:

** DONE [[file:ch06-03-if-let.md][`if let` 简洁控制流]]
CLOSED: [2024-12-26 Thu 20:45]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 20:45]
:END:

* DONE [[file:ch07-00-managing-growing-projects-with-packages-crates-and-modules.md][使用包、Crate 和模块管理不断增长的项目]] [5/5]
CLOSED: [2024-12-26 Thu 22:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:28]
:END:

** DONE [[file:ch07-01-packages-and-crates.md][包和 Crate]]
CLOSED: [2024-12-26 Thu 22:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:28]
:END:

** DONE [[file:ch07-02-defining-modules-to-control-scope-and-privacy.md][定义模块来控制作用域与私有性]]
CLOSED: [2024-12-26 Thu 22:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:28]
:END:

** DONE [[file:ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md][引用模块项目的路径]]
CLOSED: [2024-12-26 Thu 22:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:28]
:END:

** DONE [[file:ch07-04-bringing-paths-into-scope-with-the-use-keyword.md][使用 `use` 关键字将路径引入作用域]]
CLOSED: [2024-12-26 Thu 22:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:28]
:END:

** DONE [[file:ch07-05-separating-modules-into-different-files.md][将模块拆分成多个文件]]
CLOSED: [2024-12-26 Thu 22:28]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:28]
:END:

* DONE [[file:ch08-00-common-collections.md][常见集合]] [3/3]
CLOSED: [2024-12-26 Thu 22:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:40]
:END:

** DONE [[file:ch08-01-vectors.md][使用 Vector 储存列表]]
CLOSED: [2024-12-26 Thu 22:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:40]
:END:

** DONE [[file:ch08-02-strings.md][使用字符串储存 UTF-8 编码的文本]]
CLOSED: [2024-12-26 Thu 22:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:40]
:END:

let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");

字符串不能索引, 可以通过切片引用, 注意切片必须是 utf8 位置

** DONE [[file:ch08-03-hash-maps.md][使用 Hash Map 储存键值对]]
CLOSED: [2024-12-26 Thu 22:39]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:39]
:END:

* DONE [[file:ch09-00-error-handling.md][错误处理]] [3/3]
CLOSED: [2024-12-26 Thu 22:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:46]
:END:

** DONE [[file:ch09-01-unrecoverable-errors-with-panic.md][用 `panic!` 处理不可恢复的错误]]
CLOSED: [2024-12-26 Thu 22:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:46]
:END:

** DONE [[file:ch09-02-recoverable-errors-with-result.md][用 `Result` 处理可恢复的错误]]
CLOSED: [2024-12-26 Thu 22:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:46]
:END:

** DONE [[file:ch09-03-to-panic-or-not-to-panic.md][要不要 `panic!`]]
CLOSED: [2024-12-26 Thu 22:46]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 22:46]
:END:

* DONE [[file:ch10-00-generics.md][泛型、Trait 和生命周期]] [3/3]
CLOSED: [2024-12-29 Sun 14:14]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 14:14]
:END:

** DONE [[file:ch10-01-syntax.md][泛型数据类型]]
CLOSED: [2024-12-26 Thu 23:01]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-26 Thu 23:01]
:END:

** DONE [[file:ch10-02-traits.md][Trait：定义共同行为]]
CLOSED: [2024-12-29 Sun 12:22]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 12:22]
:END:

trait 作为参数

#+begin_src rust




pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}

pub fn notify(item: &(impl Summary + Display)) {

pub fn notify<T: Summary + Display>(item: &T)


fn some_function<T, U>(t: &T, u: &U) -> i32
where
    T: Display + Clone,
    U: Clone + Debug,
{
#+end_src

作为返回值,需要注意, 不能返回不同的类型, 这里要结合 Box<imp Summary>

#+begin_src rust
  fn returns_summarizable(switch: bool) -> impl Summary {
      if switch {
          NewsArticle {
              headline: String::from(
                  "Penguins win the Stanley Cup Championship!",
              ),
              location: String::from("Pittsburgh, PA, USA"),
              author: String::from("Iceburgh"),
              content: String::from(
                  "The Pittsburgh Penguins once again are the best \
                   hockey team in the NHL.",
              ),
          }
      } else {
          Tweet {
              username: String::from("horse_ebooks"),
              content: String::from(
                  "of course, as you probably already know, people",
              ),
              reply: false,
              retweet: false,
          }
      }
  }
#+end_src

** DONE [[file:ch10-03-lifetime-syntax.md][生命周期确保引用有效]]
CLOSED: [2024-12-29 Sun 14:13]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 14:13]
:END:

rust 中的每一个引用都存在生命周期,引用保持有效的作用域. 生命周期大部分时候是可以
自动推断出来的. 如果编译器不能推断的时候就需要手动标注了

最核心的是被引用的值,要在该作用域内有效

#+begin_src text
  fn main() {
      let r;                // ---------+-- 'a
                            //          |
      {                     //          |
          let x = 5;        // -+-- 'b  |
          r = &x;           //  |       |
      }                     // -+       |
                            //          |
      println!("r: {r}");   //          |
  }                         // ---------+
#+end_src
r 的生命周期是 'a, 但是 r 引用的值是 'b, 他小于'a

#+begin_src text
  fn main() {
      let x = 5;            // ----------+-- 'b
                            //           |
      let r = &x;           // --+-- 'a  |
                            //   |       |
      println!("r: {r}");   //   |       |
                            // --+       |
  }                         // ----------+
#+end_src

x 的生命周期大于 'b 大于 r 的生命周期, 所以 r 有效

#+begin_src text
  fn longest(x: &str, y: &str) -> &str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
#+end_src

x,y 和返回值都有一个生命周期, 例如叫做, 'a,'b,'c 这里并不知道返回值的'c 和'a,'b
的关系, 所以返回之后 'c 到底是否可以用就不知道了,

#+begin_src text
  fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
#+end_src
这里注释生命周期, 可以理解为 返回值的生命周期至少和输入参数中较小的一致

#+begin_src text
  fn main() {
      let string1 = String::from("long string is long");
      let result;
      {
          let string2 = String::from("xyz");
          result = longest(string1.as_str(), string2.as_str());
      }
      println!("The longest string is {result}");
  }
  // 这个不能通过,是因为 result 的生命周期和 string2 一致
#+end_src

#+begin_src text
  fn longest<'a>(x: &str, y: &str) -> &'a str {
      let result = String::from("really long string");
      result.as_str()
  }
#+end_src
当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。如
果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值。
然而它将会是一个悬垂引用，因为它将会在函数结束时离开作用域

*规则*

函数或方法的参数的生命周期被称为 输入生命周期（input lifetimes），而返回值的生命
周期被称为 输出生命周期（output lifetimes）。

第一条规则是编译器为每一个引用参数都分配一个生命周期参数。换句话说就是，函数有一
个引用参数的就有一个生命周期参数: ~fn foo<'a>(x: &'a i32)~ 有两个引用参数的函数就
有两个不同的生命周期参数 ~fn foo<'a, 'b>(x: &'a i32, y: &'b i32)~ 依此类推。

第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数 ~fn
foo<'a>(x: &'a i32) -> &'a i32~

第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self，
说明是个对象的方法 (method)(译者注：这里涉及 rust 的面向对象参见 17 章)，那么所
有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需
更少的符号。

* DONE [[file:ch11-00-testing.md][编写自动化测试]] [3/3]
CLOSED: [2024-12-29 Sun 14:29]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 14:29]
:END:

** DONE [[file:ch11-01-writing-tests.md][如何编写测试]]
CLOSED: [2024-12-29 Sun 14:20]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 14:20]
:END:

#+begin_src rust
  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn it_works() {
          let result = add(2, 2);
          assert_eq!(result, 4);
      }
  }
  #[test]
  fn greeting_contains_name() {
      let result = greeting("Carol");
      assert!(
          result.contains("Carol"),
          "Greeting did not contain name, value was `{result}`"
      );
  }
#+end_src

#+begin_src rust
  // --snip--

  impl Guess {
      pub fn new(value: i32) -> Guess {
          if value < 1 {
              panic!(
                  "Guess value must be greater than or equal to 1, got {value}."
              );
          } else if value > 100 {
              panic!(
                  "Guess value must be less than or equal to 100, got {value}."
              );
          }

          Guess { value }
      }
  }

  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      #[should_panic(expected = "less than or equal to 100")]
      fn greater_than_100() {
          Guess::new(200);
      }
  }
#+end_src
#+begin_src rust
  pub fn add(left: usize, right: usize) -> usize {
      left + right
  }

  #[cfg(test)]
  mod tests {
      use super::*;

      // ANCHOR: here
      #[test]
      fn it_works() -> Result<(), String> {
          let result = add(2, 2);

          if result == 4 {
              Ok(())
          } else {
              Err(String::from("two plus two does not equal four"))
          }
      }
      // ANCHOR_END: here
  }
#+end_src

** DONE [[file:ch11-02-running-tests.md][控制测试如何运行]]
CLOSED: [2024-12-29 Sun 14:29]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 14:29]
:END:

默认多个线程执行测试, 可以限定 ~$ cargo test -- --test-threads=1~

默认被测试的函数中有 print 时,这些 print 会被忽略, ~$ cargo test -- --show-output~
可以打开

默认忽略的测试代码, 如果希望只执行被忽略的测试 ~cargo test -- --ignored~ 或者 全部
测试 ~cargo test -- --include-ignored~
#+begin_src rust
  #[ignore]
  fn expensive_test() {
      // 需要运行一个小时的代码
  }
#+end_src

** DONE [[file:ch11-03-test-organization.md][测试的组织结构]]
CLOSED: [2024-12-29 Sun 14:29]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 14:29]
:END:

对于模块的私有函数等测试,放在模块内部

而对于希望集成测试的,放在 tests 目录下

* DONE [[file:ch12-00-an-io-project.md][一个 I/O 项目：构建命令行程序]] [6/6]
CLOSED: [2024-12-29 Sun 16:57]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 16:57]
:END:

** DONE [[file:ch12-01-accepting-command-line-arguments.md][接受命令行参数]]
CLOSED: [2024-12-29 Sun 16:50]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 16:50]
:END:

** DONE [[file:ch12-02-reading-a-file.md][读取文件]]
CLOSED: [2024-12-29 Sun 16:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 16:56]
:END:

#+begin_src rust
  use std::error::Error;

  // --snip--

  fn run(config: Config) -> Result<(), Box<dyn Error>> {
      let contents = fs::read_to_string(config.file_path)?;

      println!("With text:\n{contents}");

      Ok(())
  }

#+end_src

** DONE [[file:ch12-03-improving-error-handling-and-modularity.md][重构以改进模块化与错误处理]]
CLOSED: [2024-12-29 Sun 16:57]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 16:57]
:END:

** DONE [[file:ch12-04-testing-the-librarys-functionality.md][采用测试驱动开发完善库的功能]]
CLOSED: [2024-12-29 Sun 16:57]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 16:57]
:END:

** DONE [[file:ch12-05-working-with-environment-variables.md][处理环境变量]]
CLOSED: [2024-12-29 Sun 16:57]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 16:57]
:END:

~os.env.var~

** DONE [[file:ch12-06-writing-to-stderr-instead-of-stdout.md][将错误信息输出到标准错误而不是标准输出]]
CLOSED: [2024-12-29 Sun 16:57]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 16:57]
:END:

~eprintln!~

* DONE [[file:ch13-00-functional-features.md][Rust 中的函数式语言功能：迭代器与闭包]] [4/4]
CLOSED: [2024-12-29 Sun 19:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:42]
:END:

** DONE [[file:ch13-01-closures.md][闭包：可以捕获其环境的匿名函数]]
CLOSED: [2024-12-29 Sun 19:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:42]
:END:

它们直接对应到函数获取参数的三种方式：不可变借用、可变借用和获取所有权。闭包将根
据函数体中对捕获值的操作来决定使用哪种方式。

不可变借用
#+begin_src rust
  fn main() {
      let list = vec![1, 2, 3];
      println!("Before defining closure: {list:?}");

      let only_borrows = || println!("From closure: {list:?}");

      println!("Before calling closure: {list:?}");
      only_borrows();
      println!("After calling closure: {list:?}");
  }
#+end_src

可变借用

#+begin_src rust
  fn main() {
      let mut list = vec![1, 2, 3];
      println!("Before defining closure: {list:?}");

      let mut borrows_mutably = || list.push(7);

      borrows_mutably();
      println!("After calling closure: {list:?}");
  }
#+end_src

转移
#+begin_src rust
  use std::thread;

  fn main() {
      let list = vec![1, 2, 3];
      println!("Before defining closure: {list:?}");

      thread::spawn(move || println!("From thread: {list:?}"))
          .join()
          .unwrap();
  }
#+end_src

一旦闭包捕获了定义它的环境中的某个值的引用或所有权（也就影响了什么会被移 进 闭包，
如有），闭包体中的代码则决定了在稍后执行闭包时，这些引用或值将如何处理（也就影响
了什么会被移 出 闭包，如有）。闭包体可以执行以下任一操作：将一个捕获的值移出闭包，
修改捕获的值，既不移动也不修改值，或者一开始就不从环境中捕获任何值。

闭包捕获和处理环境中的值的方式会影响闭包实现哪些 trait，而 trait 是函数和结构体
指定它们可以使用哪些类型闭包的方式。根据闭包体如何处理这些值，闭包会自动、渐进地
实现一个、两个或全部三个 Fn trait。

FnOnce 适用于只能被调用一次的闭包。所有闭包至少都实现了这个 trait，因为所有闭包
都能被调用。一个会将捕获的值从闭包体中移出的闭包只会实现
- FnOnce trait，而不会实现其他 Fn 相关的 trait，因为它只能被调用一次。
- FnMut 适用于不会将捕获的值移出闭包体，但可能会修改捕获值的闭包。这类闭包可以被
  调用多次。
- Fn 适用于既不将捕获的值移出闭包体，也不修改捕获值的闭包，同时也包括不从环境中
  捕获任何值的闭包。这类闭包可以被多次调用而不会改变其环境，这在会多次并发调用闭
  包的场景中十分重要。

#+begin_src rust
  impl<T> Option<T> {
      pub fn unwrap_or_else<F>(self, f: F) -> T
      where
          F: FnOnce() -> T,
      {
          match self {
              Some(x) => x,
              None => f(),
          }
      }
  }
#+end_src

泛型 F 的 trait bound 是 FnOnce() -> T，这意味着 F 必须能够被调用一次，没有参数
并返回一个 T。在 trait bound 中使用 FnOnce 表示 *unwrap_or_else 最多只会调用 f 一
次*

#+begin_src rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }

  fn main() {
      let mut list = [
          Rectangle {
              width: 10,
              height: 1,
          },
          Rectangle {
              width: 3,
              height: 5,
          },
          Rectangle {
              width: 7,
              height: 12,
          },
      ];

      list.sort_by_key(|r| r.width);
      println!("{list:#?}");
  }
#+end_src

ort_by_key 被定义为接收一个 FnMut 闭包的原因是它会多次调用这个闭包：对 slice 中
的每个元素调用一次。闭包 |r| r.width 不捕获、修改或将任何东西移出它的环境，所以
它满足 trait bound 的要求。


#+begin_src rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }

  fn main() {
      let mut list = [
          Rectangle {
              width: 10,
              height: 1,
          },
          Rectangle {
              width: 3,
              height: 5,
          },
          Rectangle {
              width: 7,
              height: 12,
          },
      ];

      let mut sort_operations = vec![];
      let value = String::from("closure called");

      list.sort_by_key(|r| {
          sort_operations.push(value);
          r.width
      });
      println!("{list:#?}");
  }
#+end_src
上面这个变异失败是因为 value 是 String 没有实现 copy, 它转移了 value 到闭包中,
而发生转移的闭包只能是 FnOnce

下面这个闭包只是可变应用了一个值,所以可以满足 FnMut

#+begin_src rust
  #[derive(Debug)]
  struct Rectangle {
      width: u32,
      height: u32,
  }

  fn main() {
      let mut list = [
          Rectangle {
              width: 10,
              height: 1,
          },
          Rectangle {
              width: 3,
              height: 5,
          },
          Rectangle {
              width: 7,
              height: 12,
          },
      ];

      let mut num_sort_operations = 0;
      list.sort_by_key(|r| {
          num_sort_operations += 1;
          r.width
      });
      println!("{list:#?}, sorted in {num_sort_operations} operations");
  }
#+end_src

** DONE [[file:ch13-02-iterators.md][使用迭代器处理元素序列]]
CLOSED: [2024-12-29 Sun 19:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:42]
:END:

迭代器是惰性的, 如果没有被消费编译会警告, 有些函数是生成一个迭代器,叫做迭代器适
配器

** DONE [[file:ch13-03-improving-our-io-project.md][改进之前的 I/O 项目]]
CLOSED: [2024-12-29 Sun 19:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:42]
:END:

** DONE [[file:ch13-04-performance.md][性能比较：循环对迭代器]]
CLOSED: [2024-12-29 Sun 19:42]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:42]
:END:

* DONE [[file:ch14-00-more-about-cargo.md][更多关于 Cargo 和 Crates.io 的内容]] [5/5]
CLOSED: [2024-12-29 Sun 19:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:56]
:END:

** DONE [[file:ch14-01-release-profiles.md][采用发布配置自定义构建]]
CLOSED: [2024-12-29 Sun 19:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:47]
:END:

** DONE [[file:ch14-02-publishing-to-crates-io.md][将 crate 发布到 Crates.io]]
CLOSED: [2024-12-29 Sun 19:47]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:47]
:END:

** DONE [[file:ch14-03-cargo-workspaces.md][Cargo 工作空间]]
CLOSED: [2024-12-29 Sun 19:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:56]
:END:

workspace/Cargo.toml
#+begin_src toml
  [workspace]

  members = [
      "adder",
      "add_one",
  ]

  # 这是在工作空间中有两个 crate, 如果 adder crate 中希望使用 add_one 库, 那么可以
  # 在 adder 的 Cargo.toml 中如下
  [dependencies]
  add_one = { path = "../add_one" }
#+end_src

还需注意的是工作空间只在根目录有一个 Cargo.lock，而不是在每一个 crate 目录都有
Cargo.lock。这确保了所有的 crate 都使用完全相同版本的依赖。如果在 Cargo.toml 和
add_one/Cargo.toml 中都增加 rand crate，则 Cargo 会将其都解析为同一版本并记录到
唯一的 Cargo.lock 中。使得工作空间中的所有 crate 都使用相同的依赖意味着其中的
crate 都是相互兼容的。让我们在 add_one/Cargo.toml 中的 [dependencies] 部分增加
rand crate 以便能够在 add_one crate 中使用 rand crate：

但是每个 package  希望使用外部包时,都是必须要在自己的 Cargo.toml 中引入的

在工作空间中执行 cargo 命令 可以使用 ~-p~ 参数指定要执行的那一个 Package

** DONE [[file:ch14-04-installing-binaries.md][使用 `cargo install` 安装二进制文件]]
CLOSED: [2024-12-29 Sun 19:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:56]
:END:

** DONE [[file:ch14-05-extending-cargo.md][Cargo 自定义扩展命令]]
CLOSED: [2024-12-29 Sun 19:56]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-12-29 Sun 19:56]
:END:

可执行目录下的 cargo-something 那么 cargo something 就是执行那个文件

* TODO [[file:ch15-00-smart-pointers.md][智能指针]] [0/6]
** TODO [[file:ch15-01-box.md][使用 `Box<T>` 指向堆上数据]]
** TODO [[file:ch15-02-deref.md][使用 `Deref` Trait 将智能指针当作常规引用处理]]
** TODO [[file:ch15-03-drop.md][使用 `Drop` Trait 运行清理代码]]
** TODO [[file:ch15-04-rc.md][`Rc<T>` 引用计数智能指针]]
** TODO [[file:ch15-05-interior-mutability.md][`RefCell<T>` 与内部可变性模式]]
** TODO [[file:ch15-06-reference-cycles.md][引用循环会导致内存泄漏]]

* TODO [[file:ch16-00-concurrency.md][无畏并发]] [0/4]
** TODO [[file:ch16-01-threads.md][使用线程同时地运行代码]]
** TODO [[file:ch16-02-message-passing.md][使用消息传递在线程间通信]]
** TODO [[file:ch16-03-shared-state.md][共享状态并发]]
** TODO [[file:ch16-04-extensible-concurrency-sync-and-send.md][使用 `Sync` 与 `Send` Traits 的可扩展并发]]

* TODO [[file:ch17-00-async-await.md][Async 和 await]] [0/6]
** TODO [[file:ch17-01-futures-and-syntax.md][Futures 和 async 语法]]
** TODO [[file:ch17-02-concurrency-with-async.md][并发与 async]]
** TODO [[file:ch17-03-more-futures.md][使用任意数量的 futures]]
** TODO [[file:ch17-04-streams.md][流（Streams）]]
** TODO [[file:ch17-05-traits-for-async.md][深入理解 async 相关的 traits]]
** TODO [[file:ch17-06-futures-tasks-threads.md][Futures，任务（tasks）和线程（threads）]]

* TODO [[file:ch18-00-oop.md][Rust 的面向对象编程特性]] [0/3]
** TODO [[file:ch18-01-what-is-oo.md][面向对象语言的特点]]
** TODO [[file:ch18-02-trait-objects.md][顾及不同类型值的 trait 对象]]
** TODO [[file:ch18-03-oo-design-patterns.md][面向对象设计模式的实现]]

* TODO [[file:ch19-00-patterns.md][模式与模式匹配]] [0/3]
** TODO [[file:ch19-01-all-the-places-for-patterns.md][所有可能会用到模式的位置]]
** TODO [[file:ch19-02-refutability.md][Refutability（可反驳性）: 模式是否会匹配失效]]
** TODO [[file:ch19-03-pattern-syntax.md][模式语法]]

* TODO [[file:ch20-00-advanced-features.md][高级特征]] [0/5]
** TODO [[file:ch20-01-unsafe-rust.md][不安全的 Rust]]
** TODO [[file:ch20-03-advanced-traits.md][高级 trait]]
** TODO [[file:ch20-04-advanced-types.md][高级类型]]
** TODO [[file:ch20-05-advanced-functions-and-closures.md][高级函数与闭包]]
** TODO [[file:ch20-06-macros.md][宏]]

* TODO [[file:ch21-00-final-project-a-web-server.md][最后的项目：构建多线程 web server]] [0/3]
** TODO [[file:ch21-01-single-threaded.md][建立单线程 web server]]
** TODO [[file:ch21-02-multithreaded.md][将单线程 server 变为多线程 server]]
** TODO [[file:ch21-03-graceful-shutdown-and-cleanup.md][优雅停机与清理]]

* TODO [[file:appendix-00.md][附录]] [0/7]
** TODO [[file:appendix-01-keywords.md][A - 关键字]]
** TODO [[file:appendix-02-operators.md][B - 运算符与符号]]
** TODO [[file:appendix-03-derivable-traits.md][C - 可派生的 trait]]
** TODO [[file:appendix-04-useful-development-tools.md][D - 实用开发工具]]
** TODO [[file:appendix-05-editions.md][E - 版本]]
** TODO [[file:appendix-06-translation.md][F - 本书译本]]
** TODO [[file:appendix-07-nightly-rust.md][G - Rust 是如何开发的与 “Nightly Rust”]]
